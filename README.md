# Комплексне дослідження структури, конфігурацій та робочого середовища сучасного JavaScript-проєкту на основі бойлерплейта vite-react-boilerplate

## Мета
- Познайомитись із структурою файлу `package.json` як центрального конфігураційного файлу JavaScript-проєкту, зрозуміти основні поля: імʼя, автор, опис, версія, ліцензія, репозиторій, скрипти та залежності.
- Вивчити принципи семантичного версіонування (SemVer) через аналіз реальних залежностей.
- Ознайомитись із практикою оформлення проєктної документації (README.md).
- Вивчити призначення файлів `.gitignore` та `LICENSE`.
- Розібратися з роботою гіт-хуків через аналіз артефактів, які створює бібліотека Husky.

## Завдання

## 1. Початкова підготовка середовища
1. **Склонуйте репозиторій vite-react-boilerplate.**
2. **Встановіть усі залежності проєкту, використовуючи команду pnpm install.**
3. **Запустіть початковий скрипт сетапу проєкту (pnpm run setup).**

- Склоновано репозиторій [vite-react-boilerplate](https://github.com/edwardhinkle/vite-react-boilerplate)
![image](https://github.com/user-attachments/assets/ac4ec776-2824-413c-a3d1-f6b3c9f3e667)
- Встановлено залежності:
  ```bash  
  pnpm install
![image](https://github.com/user-attachments/assets/3842fa92-2603-422a-99b5-54c00e1e9d4f)
![image](https://github.com/user-attachments/assets/2ff7fcc4-8b1b-4a13-b426-919f6ba998f4)
- Запущено скрипт ініціалізації:
  ```bash
  pnpm run setup
![image](https://github.com/user-attachments/assets/42bef798-3054-43e1-85e3-835d8de226c4)

## 2. Аналіз структури файлу package.json
1. **Опишіть у звіті призначення полів файлу package.json: name, author, description, version, license, repository, scripts, dependencies, devDependencies.**
2. **Проаналізуйте залежності, вказані у dependencies та devDependencies, поясніть логіку такої класифікації.**

- name — це ім’я проєкту. У нашому випадку, це "vite-react-boilerplate", що вказує на шаблон для проєктів на основі Vite та React.
- author — тут зазначений автор проєкту. "Ricardo Valdovinos <ricardovaldovinos1996@gmail.com>".
- description — короткий опис проєкту, що допомагає зрозуміти, що це за проєкт. У нашому випадку це шаблон для швидкого старту з Vite та React.
- version — версія проєкту. Це корисно для відслідковування змін у проєкті. 
- license — ліцензія, під якою розповсюджується проєкт. Використовується "MIT", що дозволяє вільно використовувати код, якщо зазначено авторство.
- repository — вказує на репозиторій Git, де зберігається код проєкту.
"repository": {
  "type": "git",
  "url": "https://github.com/RicardoValdovinos/vite-react-boilerplate"
}
![image](https://github.com/user-attachments/assets/edaf30eb-d2db-4785-879a-1729e4ef3d52)

У файлі є розділ scripts, в якому зібрані різні команди для автоматизації процесів:
- setup — виконує налаштування проєкту, наприклад, ініціалізує Git, встановлює Husky для гіт-хуків, встановлює Playwright для тестування.
"setup": "git init && npx husky init && npx playwright install && shx rm .husky/pre-commit"
- format — запускає Prettier для форматування всіх TypeScript файлів у проєкті: "format": "prettier \"src/**/*.{ts,tsx}\" --write"
- lint — запускає ESLint для перевірки коду на помилки: "lint": "eslint --max-warnings 0"
- dev — запускає сервер для розробки з Vite: "dev": "vite"
- test — запускає тести за допомогою Vitest та Playwright: "test": "vitest run src/ && playwright test"
![image](https://github.com/user-attachments/assets/e3a83c2e-9c6f-4038-b8eb-0e9b32e199d5)

У розділі dependencies описані бібліотеки, які потрібні для роботи додатку:
- react та react-dom — основні бібліотеки для роботи з React.
- @tanstack/react-query — бібліотека для роботи з асинхронними запитами, яка спрощує обробку даних.
- dayjs — бібліотека для роботи з датами.
- i18next — бібліотека для локалізації, тобто підтримки кількох мов у додатку.
![image](https://github.com/user-attachments/assets/ba40e497-40d5-4525-bb8a-5bee81341069)


devDependencies використовуються лише під час розробки, тестування чи для зручності налаштувань:
- eslint — для перевірки коду на помилки і підтримки високих стандартів коду.
- prettier — для автоматичного форматування коду.
- husky — для налаштування гіт-хуків, щоб перевіряти код перед комітом.
- vitest — тестувальний фреймворк для запуску юніт-тестів.
- @storybook/react — інструмент для розробки компонентів UI, що дозволяє їх переглядати і тестувати без запуску всього проєкту.
![image](https://github.com/user-attachments/assets/8749b8f2-e8b8-468c-9f29-4f504fe86945)
![image](https://github.com/user-attachments/assets/c4bb51fe-e3ad-43bb-b90d-2c09baefaf55)

dependencies містять бібліотеки, необхідні для роботи додатку в продакшн-середовищі. Це те, без чого додаток не працюватиме
devDependencies — це бібліотеки, які використовуються тільки в процесі розробки, тестування, або для автоматизації деяких процесів. Вони не потрібні для роботи додатку в продакшн-середовищі, тому їх не включають у фінальний реліз.

## 3. Семантичне версіонування (SemVer)
1. **Ознайомтесь із принципами SemVer.**
2. **Дослідіть версії пакетів бойлерплейту. Поясніть, які оновлення (мажорні, мінорні, патчі) допускаються відповідно до версій, зазначених у файлі package.json.**

У файлі package.json основні залежності мають різні рівні оновлень:
Залежність "react": "^18.3.1" дозволяє оновлення мінорного і патч-рівня, але не дозволяє оновлення до 19.x.x.
Залежність "vite": "5.4.2" не має знаку каретки, що означає, що вона не допускає автоматичні оновлення до новіших версій, ніж 5.4.2.
Для інших залежностей, таких як tailwindcss, typescript, "vitest", також використовуються знаки каретки, що дозволяє мінорні й патч-оновлення.
Тому з точки зору SemVer в цьому проекті можна оновлювати залежності на рівні мінорних і патч-версій без порушення сумісності з попередніми версіями.
![image](https://github.com/user-attachments/assets/1533dfc5-4a20-48d3-880c-d4d6eaedeb50)

## 4. Дослідження додаткових конфігураційних файлів
**Проаналізуйте та опишіть призначення, структуру та важливі елементи файлів: README.md, .gitignore, LICENSE**

- README.md  
Файл README.md містить основну інформацію про проект, його мету, вимоги та інструкції з налаштування. Він описує технології, які використовуються, зокрема Vite, React, TypeScript та інші. Також надаються інструкції для початку роботи, запуску тестів і підготовки до розгортання. Важливі частини включають опис інструментів розробника та встановлених пакетів.
![image](https://github.com/user-attachments/assets/9f3db704-c0c2-48a9-b404-03e0c64f6d57)

- .gitignore  
Файл .gitignore визначає, які файли та директорії не повинні потрапляти в систему контролю версій Git. Він виключає логи, залежності, файли конфігурацій редакторів та тимчасові файли. Також ігнорує директорії для тестів та специфічні файли, пов'язані з різними інструментами розробки. Це забезпечує чистоту репозиторію та зменшує обсяг зайвих файлів.
![image](https://github.com/user-attachments/assets/09001eda-0049-49cc-b0bc-04b976c3e827)

- LICENSE  
Файл LICENSE містить ліцензію MIT, яка дозволяє користувачам вільно використовувати, копіювати, змінювати та поширювати програмне забезпечення. Проте вимагається включення авторських прав і ліцензійного повідомлення в усі копії програмного забезпечення. Ліцензія також застерігає від будь-яких гарантій щодо використання програмного забезпечення. Це один з найпоширеніших типів ліцензій в open-source проектах.
![image](https://github.com/user-attachments/assets/6e5676ec-9efc-4dde-a8d1-035e8770108b)

# 5. Аналіз роботи гіт-хуків Husky
![image](https://github.com/user-attachments/assets/b27277b4-bd35-4ed7-8630-c7a944c5ff52)

### .husky/
Ця директорія містить налаштування та скрипти для гіт-хуків, які використовуються для автоматизації різних етапів процесу розробки.
### .gitignore
Файл `.gitignore` необхідний для того, щоб ігнорувати директорії та файли, пов'язані з Husky, щоб вони не потрапляли в репозиторій.
### applypatch-msg
Цей хук виконується перед застосуванням патча та дозволяє перевірити або змінити повідомлення про патч перед його застосуванням.
### commit-msg
Цей хук перевіряє повідомлення коміту, щоб забезпечити правильний формат згідно з налаштуваннями (наприклад, використовувати Conventional Commits).
### h
Файл `h` є базовим виконуваним скриптом для налаштування та запуску хуків в середовищі командного рядка.
### husky.sh
Цей скрипт забезпечує базову підтримку для роботи з хуками Husky, зокрема він дозволяє ініціалізувати та налаштовувати хуки в проекті.
### post-applypatch
Хук `post-applypatch` виконується після того, як патч застосовано, і може бути використаний для додаткової обробки чи перевірок.
### post-checkout
Цей хук виконується після checkout, що дозволяє виконувати додаткові налаштування чи оновлення після переключення між гілками.
### post-commit
Хук `post-commit` запускається після коміту, він може бути використаний для додаткових перевірок чи дій після виконання коміту.
### post-merge
Цей хук виконується після злиття гілок і може використовуватись для автоматичних дій після злиття, наприклад, для оновлення залежностей.
### post-rewrite
Хук `post-rewrite` виконується після перезапису історії комітів, наприклад, після використання `git rebase`.
### pre-applypatch
Цей хук виконується перед застосуванням патча і може бути використаний для перевірки чи зміни патча перед його застосуванням.
### pre-auto-gc
Хук `pre-auto-gc` виконується перед автоматичним збором сміття Git, і може бути використаний для попередження або перевірки змін.
### pre-commit
Цей хук запускається перед комітом і зазвичай використовується для перевірок коду, наприклад, для лінтингу чи тестування.
### pre-merge-commit
Хук `pre-merge-commit` виконується перед комітом злиття і може бути використаний для перевірки перед злиттям гілок.
### pre-push
Цей хук виконується перед пушем на віддалений репозиторій, дозволяючи перевірити зміни перед відправленням на сервер.
### pre-rebase
Хук `pre-rebase` виконується перед ребейзом, що дозволяє автоматично виконати перевірки або обробку перед зміною історії.
### prepare-commit-msg
Цей хук виконується перед відкриттям редактора для введення повідомлення коміту, і дозволяє автоматично підготувати шаблон для повідомлення.

# 6. Використання змінних оточення
1. **Напишіть скрипт, який буде читати довільну змінну оточення та друкувати її значення у консоль.**
2. **Задайте різне значення змінної оточення на різних рівнях (ОС, сесія терміналу, окремий запуск скрипта, dotEnv файл) та дослідіть пріоритетність їх застосування.**
3. **Зафіксуйте отримані результати.**

- Створено скрипт env_variables.js:
![image](https://github.com/user-attachments/assets/e5f96ac3-8673-4f60-9b79-6fbb9c6c8c04)
- файл .env  
![image](https://github.com/user-attachments/assets/bb8ce02f-3897-4718-a86e-32ccb5428b7f)
- По дефолту виводить такі значення:  
![image](https://github.com/user-attachments/assets/dba0b13e-2d7f-462f-a5ab-51a0594b1f94)
- Зміна змінних через термінал та вивід:  
![image](https://github.com/user-attachments/assets/baa76442-294d-470c-8163-8528d78304bb)  
![image](https://github.com/user-attachments/assets/12f5215e-d825-4530-92ce-3d7c7e90ea18)

# Висновок
У цій лабораторній роботі було здійснено повне ознайомлення зі структурою сучасного JavaScript-проєкту на основі шаблону Vite та React. Було встановлено залежності, виконано початкову ініціалізацію проєкту та вивчено ключові конфігураційні файли, зокрема package.json, .gitignore, README.md та LICENSE. Особливу увагу приділено аналізу залежностей та принципам семантичного версіонування. Також досліджено механізм роботи гіт-хуків Husky та принципи використання змінних оточення через файл .env, налаштування терміналу та тимчасові значення. Робота дозволила сформувати цілісне уявлення про структуру, налаштування та запуск сучасного JavaScript-проєкту.
